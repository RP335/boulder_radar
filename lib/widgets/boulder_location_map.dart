// lib/widgets/boulder_location_map.dart

import 'dart:convert';
import 'dart:typed_data'; // Required for Uint8List
import 'dart:ui' as ui; // Required for PictureRecorder and Canvas
import 'package:flutter/material.dart';
import 'package:geolocator/geolocator.dart' as geo;
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:http/http.dart' as http;

class BoulderLocationMap extends StatefulWidget {
  final double boulderLatitude;
  final double boulderLongitude;
  final bool isOffline;

  const BoulderLocationMap({
    Key? key,
    required this.boulderLatitude,
    required this.boulderLongitude,
    this.isOffline = false,
  }) : super(key: key);

  @override
  State<BoulderLocationMap> createState() => _BoulderLocationMapState();
}

class _BoulderLocationMapState extends State<BoulderLocationMap> {
  // IMPORTANT: Replace this with your actual Mapbox public token
  static const String _mapboxAccessToken =
      '';
  MapboxMap? _mapboxMap;
  PointAnnotationManager? _pointAnnotationManager;
  geo.Position? _userPosition;
  bool _isLoading = true;
  String? _error;
  String _currentMapStyle = MapboxStyles.MAPBOX_STREETS;


  @override
  void initState() {
    super.initState();
    _initialize();
  }

  Future<void> _initialize() async {
    // Only get user location if we are online and need to draw a route
    if (!widget.isOffline) {
      await _getUserLocation();
    }
    if (mounted) {
      setState(() {
        _isLoading = false;
      });
    }
  }

  Future<void> _getUserLocation() async {
    try {
      var permission = await geo.Geolocator.checkPermission();
      if (permission == geo.LocationPermission.denied) {
        permission = await geo.Geolocator.requestPermission();
      }
      if (permission == geo.LocationPermission.denied ||
          permission == geo.LocationPermission.deniedForever) {
        setState(() => _error = "Location permission denied to show route.");
        return;
      }
      _userPosition = await geo.Geolocator.getCurrentPosition(
        desiredAccuracy: geo.LocationAccuracy.high,
      );
    } catch (e) {
      // Don't treat this as a fatal error, we just won't show the route
      print("Could not get user location: ${e.toString()}");
    }
  }

  /// Creates a custom marker image by drawing on a Canvas.
  Future<Uint8List> _createBoulderMarkerImage() async {
    final ui.PictureRecorder recorder = ui.PictureRecorder();
    final Canvas canvas = Canvas(recorder);
    // Use a color that contrasts with the purple route line, like red or orange
    final Paint paint = Paint()..color = Colors.redAccent;
    const double radius = 35.0; // A bit larger for visibility

    // Draw outer circle
    canvas.drawCircle(const Offset(radius, radius), radius, paint);

    // Draw a smaller white inner circle to make it look like a pin
    paint.color = Colors.white;
    canvas.drawCircle(const Offset(radius, radius), radius * 0.4, paint);

    final img = await recorder.endRecording().toImage(
          (radius * 2).toInt(),
          (radius * 2).toInt(),
        );
    final data = await img.toByteData(format: ui.ImageByteFormat.png);
    return data!.buffer.asUint8List();
  }

  Future<void> _onMapCreated(MapboxMap mapboxMap) async {
    _mapboxMap = mapboxMap;
    
    // Explicitly enable gestures for smooth interaction
    _mapboxMap?.gestures.updateSettings(
        GesturesSettings(pinchToZoomEnabled: true, scrollEnabled: true));
        
    _mapboxMap?.location
        .updateSettings(LocationComponentSettings(enabled: true));

    // Generate the marker image dynamically
    final markerBytes = await _createBoulderMarkerImage();
    await _addBoulderMarker(markerBytes);

    if (_userPosition != null && !widget.isOffline) {
      await _fetchRouteAndDraw();
      _zoomToFitRoute();
    } else {
      // If no user location or offline, just fly to the boulder
      _mapboxMap?.flyTo(
          CameraOptions(
              center: Point(
                  coordinates: Position(
                      widget.boulderLongitude, widget.boulderLatitude)),
              zoom: 15),
          null);
    }
  }

  /// Adds the dynamically created marker to the map.
  Future<void> _addBoulderMarker(Uint8List markerImage) async {
    _pointAnnotationManager ??=
        await _mapboxMap?.annotations.createPointAnnotationManager();
    final options = PointAnnotationOptions(
      geometry: Point(
          coordinates:
              Position(widget.boulderLongitude, widget.boulderLatitude)),
      // Use the generated byte data for the image
      image: markerImage,
      iconSize: 0.8,
      iconAnchor: IconAnchor.CENTER,
    );
    _pointAnnotationManager?.create(options);
  }

  Future<void> _fetchRouteAndDraw() async {
    // This check correctly prevents network errors when offline
    if (widget.isOffline) {
      return;
    }
    if (_userPosition == null) return;

    final origin = _userPosition!;
    final destination = Point(
        coordinates: Position(widget.boulderLongitude, widget.boulderLatitude));
    final url =
        'https://api.mapbox.com/directions/v5/mapbox/walking/${origin.longitude},${origin.latitude};${destination.coordinates.lng},${destination.coordinates.lat}?geometries=geojson&access_token=$_mapboxAccessToken';

    try {
      final response = await http.get(Uri.parse(url));
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final route = data['routes'][0]['geometry'];

        if (await _mapboxMap?.style.styleSourceExists('route-source') ==
            false) {
          await _mapboxMap?.style.addSource(
              GeoJsonSource(id: 'route-source', data: json.encode(route)));
        }

        if (await _mapboxMap?.style.styleLayerExists('route-layer') == false) {
          await _mapboxMap?.style.addLayer(LineLayer(
            id: 'route-layer',
            sourceId: 'route-source',
            lineColor: Colors.deepPurpleAccent.value,
            lineWidth: 5.0,
            lineOpacity: 0.8,
          ));
        }
      } else {
        throw Exception('Failed to load route: ${response.body}');
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error fetching directions: ${e.toString()}')),
        );
      }
    }
  }

  void _zoomToFitRoute() async {
    if (_userPosition == null || _mapboxMap == null) return;

    final MbxEdgeInsets padding =
        MbxEdgeInsets(top: 50.0, left: 50.0, bottom: 50.0, right: 50.0);

    final CameraOptions cameraOptions = await _mapboxMap!.cameraForCoordinates(
      [
        Point(
            coordinates:
                Position(_userPosition!.longitude, _userPosition!.latitude)),
        Point(
            coordinates:
                Position(widget.boulderLongitude, widget.boulderLatitude)),
      ],
      padding,
      null, // bearing
      null, // pitch
    );

    _mapboxMap?.flyTo(cameraOptions, MapAnimationOptions(duration: 1500));
  }
  
  void _toggleMapStyle() {
    setState(() {
      _currentMapStyle = _currentMapStyle == MapboxStyles.SATELLITE_STREETS
          ? MapboxStyles.MAPBOX_STREETS
          : MapboxStyles.SATELLITE_STREETS;
    });
     // Update the style on the map controller
    _mapboxMap?.loadStyleURI(_currentMapStyle);
  }


  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const AspectRatio(
        aspectRatio: 16 / 10,
        child: Center(child: CircularProgressIndicator()),
      );
    }
    if (_error != null) {
      return AspectRatio(
        aspectRatio: 16 / 10,
        child: Container(
          decoration: BoxDecoration(
              color: Colors.grey.shade800,
              borderRadius: BorderRadius.circular(12)),
          child: Center(
              child: Padding(
            padding: const EdgeInsets.all(8.0),
            child: Text(
              _error!,
              style: const TextStyle(color: Colors.red),
              textAlign: TextAlign.center,
            ),
          )),
        ),
      );
    }
    return AspectRatio(
      aspectRatio: 16 / 10,
      child: Stack(
        children: [
          Container(
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              border: Border.all(color: Colors.grey.shade700, width: 1.5),
            ),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(10.5),
              child: MapWidget(
                onMapCreated: _onMapCreated,
                // Use the optimize flag for better performance
                styleUri: '$_currentMapStyle?optimize=true',
              ),
            ),
          ),
          Positioned(
            top: 10,
            right: 10,
            child: FloatingActionButton.small(
              heroTag: 'toggleStyleFabBoulderMap', // Unique heroTag
              backgroundColor: Colors.black.withOpacity(0.6),
              onPressed: _toggleMapStyle,
              tooltip: 'Toggle Map Style',
              child: Icon(
                _currentMapStyle == MapboxStyles.SATELLITE_STREETS
                    ? Icons.map_outlined
                    : Icons.satellite_alt_outlined,
                color: Colors.white,
              ),
            ),
          ),
        ],
      ),
    );
  }
}